---
title: Autenticaci√≥n y Autorizaci√≥n
description: Documentaci√≥n del sistema de autenticaci√≥n JWT y control de acceso RBAC.
sidebar:
  label: Autenticaci√≥n
  order: 2
updated: 2026-01-03
---

import { Tabs, TabItem, Aside, Steps, Code } from '@astrojs/starlight/components';

El sistema Nostromo utiliza **JSON Web Tokens (JWT)** para la autenticaci√≥n stateless y **Role-Based Access Control (RBAC)** para la autorizaci√≥n granular.

---

## Mecanismo de Autenticaci√≥n

A diferencia de sistemas tradicionales basados en sesi√≥n, Nostromo utiliza un enfoque **Token-Based**:

<Steps>
1. **Frontend** env√≠a credenciales (`email`, `password`) al endpoint `/auth/login`
2. **Backend** valida contra hash en BD usando `bcrypt`
3. **Backend** retorna un JWT firmado con `JWT_SECRET`
4. **Frontend** almacena token en cookie `sid` (httpOnly)
5. **Requests subsiguientes** incluyen token autom√°ticamente
</Steps>

<Aside type="caution" title="Formato del Header">
  El token debe enviarse con el prefijo `Bearer`:
  ```
  Authorization: Bearer <TOKEN_JWT>
  ```
  O via cookie `sid` (preferido para seguridad).
</Aside>

---

## Flujo de Secuencia

```mermaid
%%{init: {'theme': 'dark', 'themeVariables': { 'primaryColor': '#2a2a2a', 'primaryTextColor': '#e0e0e0', 'lineColor': '#f38020'}}}%%
sequenceDiagram
    participant U as üë§ Usuario
    participant F as üèùÔ∏è Sevastopol
    participant A as üéØ Orchestrator
    participant D as üóÑÔ∏è PostgreSQL
    
    U->>F: Ingresa credenciales
    F->>A: POST /auth/login
    A->>D: SELECT * FROM auth.users WHERE email=$1
    D-->>A: User Hash
    A->>A: bcrypt.compare(pass, hash)
    
    alt ‚úÖ Credenciales v√°lidas
        A->>A: Generar JWT (sign)
        A-->>F: { token, user_data }
        Note over A,F: Set-Cookie: sid=<JWT>
        F->>U: Redirige al Dashboard
    else ‚ùå Inv√°lidas
        A-->>F: 401 Unauthorized
        F->>U: Muestra error
    end
```

---

## Estructura del Token

<Tabs>
  <TabItem label="Payload JWT">
    El JWT contiene informaci√≥n para el contexto de la solicitud, pero **no contiene secretos**:

    ```json title="JWT Payload"
    {
      "userId": "uuid-v4-del-usuario",
      "email": "usuario@empresa.com",
      "role": "ADMIN",
      "iat": 1703698000,
      "exp": 1703784400
    }
    ```

    | Campo | Descripci√≥n |
    | :--- | :--- |
    | `userId` | UUID √∫nico del usuario |
    | `email` | Email para logging/audit |
    | `role` | Rol global (SUPER_ADMIN, ADMIN, USER, RO) |
    | `iat` | Timestamp de emisi√≥n |
    | `exp` | Expiraci√≥n (24h por defecto) |
  </TabItem>

  <TabItem label="Cookie sid">
    En producci√≥n, el token se almacena en una cookie segura:

    ```http title="Set-Cookie Header"
    Set-Cookie: sid=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...;
      Path=/;
      HttpOnly;
      Secure;
      SameSite=Strict;
      Max-Age=86400
    ```

    <Aside type="tip" title="Seguridad">
      - `HttpOnly` previene acceso desde JavaScript (XSS)
      - `Secure` solo permite HTTPS
      - `SameSite=Strict` previene CSRF
    </Aside>
  </TabItem>
</Tabs>

---

## Middleware de Protecci√≥n

El backend utiliza un middleware `authenticateToken` que intercepta todas las rutas protegidas:

```typescript title="middleware/auth.ts"
import jwt from 'jsonwebtoken';
import cookie from 'cookie';

export const authenticateToken = (req, res, next) => {
  // 1. Intentar obtener token del header Authorization
  const authHeader = req.headers['authorization'];
  let token = authHeader?.split(' ')[1]; // Bearer TOKEN

  // 2. Fallback: buscar en cookie sid
  if (!token && req.headers.cookie) {
    const parsed = cookie.parse(req.headers.cookie);
    token = parsed.sid;
  }

  if (!token) {
    return res.status(401).json({ success: false, error: 'No authorization token' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!);
    req.user = decoded; // Inyecta usuario en el request
    next();
  } catch {
    return res.status(403).json({ success: false, error: 'Invalid or expired token' });
  }
};
```

---

## Roles y Permisos (RBAC)

Aunque el JWT valida la **identidad**, los permisos espec√≠ficos se validan mediante el sistema RBAC:

| Rol | Alcance | Descripci√≥n |
| :--- | :--- | :--- |
| **SUPER_ADMIN** | üåç Global | Acceso total a todos los tenants y configuraci√≥n de sistema |
| **ADMIN** | üè¢ Tenant | Acceso total dentro de su organizaci√≥n |
| **USER** | üè¢ Tenant | Acceso est√°ndar para operar m√≥dulos |
| **RO** | üè¢ Tenant | Solo lectura para auditores |

<Tabs>
  <TabItem label="Middleware RBAC">
    ```typescript title="lib/rbac.ts"
    export const authorizeRoute = (req, res, next) => {
      const { role } = req.user;
      const route = req.originalUrl.split('?')[0];

      if (!rbac.canAccess(role, route)) {
        return res.status(403).json({ 
          success: false, 
          error: `Access denied for role '${role}'` 
        });
      }
      next();
    };
    ```
  </TabItem>

  <TabItem label="Uso en Rutas">
    ```typescript title="routes/command/tenant.ts"
    import { authenticateToken, authorizeRoute } from '@/middleware/auth';

    // Solo SUPER_ADMIN puede eliminar tenants
    router.delete('/', 
      authenticateToken, 
      authorizeRoute, 
      async (req, res) => {
        // ... l√≥gica de eliminaci√≥n
      }
    );
    ```
  </TabItem>
</Tabs>

<Aside type="note" title="Configuraci√≥n de Rutas">
  Las rutas permitidas por rol se configuran en [lib/rbac.ts](../../Accounting/orchestrator/src/lib/rbac.ts).
</Aside>
