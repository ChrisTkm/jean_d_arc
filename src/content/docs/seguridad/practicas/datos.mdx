---
title: Protecci√≥n de Datos
description: Protocolos para el manejo seguro de informaci√≥n sensible y PII.
sidebar:
  label: Protecci√≥n de Datos
  order: 2
updated: 2026-01-03
---

import { Tabs, TabItem, Aside, Steps } from '@astrojs/starlight/components';

La protecci√≥n de datos es cr√≠tica, especialmente al manejar informaci√≥n financiera y personal (PII) en los m√≥dulos de Remuneraciones y Contabilidad.

---

## Clasificaci√≥n de Datos

| Nivel | Descripci√≥n | Ejemplos | Controles |
| :--- | :--- | :--- | :--- |
| üü¢ **P√∫blico** | Informaci√≥n no sensible | Docs t√©cnicos, Landing page | Ninguno espec√≠fico |
| üü° **Interno** | Uso exclusivo de la org | IDs de usuario, config UI | Autenticaci√≥n requerida |
| üü† **Confidencial** | Informaci√≥n sensible del negocio | Detalles de contratos, montos | RBAC, Auditor√≠a de acceso |
| üî¥ **Cr√≠tico** | PII y secretos | RUT, Sueldos, Claves, Tokens | Cifrado, Acceso restringido, Logs enmascarados |

---

## Manejo de Secretos

<Steps>
1. **Nunca** commitear credenciales en Git (`.env` est√° en `.gitignore`)
2. En desarrollo local, usar `.env.local` no compartido
3. En producci√≥n (Render/Cloudflare), inyectar secretos como Variables de Entorno
4. Rotar llaves cr√≠ticas (DB Password, JWT Secret) cada **90 d√≠as**
</Steps>

<Aside type="caution" title="Rotaci√≥n de Emergencia">
  Ante sospecha de compromiso, rotar credenciales **inmediatamente** sin esperar el ciclo regular.
</Aside>

---

## Enmascaramiento en Logs

Para prevenir fugas de datos en sistemas de monitoreo, sanitiza objetos antes de loguear:

```typescript title="utils/sanitize.ts"
const SENSITIVE_KEYS = ['password', 'token', 'secret', 'rut', 'sueldo', 'clave'];

function sanitizeLog(data: Record<string, any>): Record<string, any> {
  const sanitized: Record<string, any> = {};
  
  for (const [key, value] of Object.entries(data)) {
    if (SENSITIVE_KEYS.some(k => key.toLowerCase().includes(k))) {
      sanitized[key] = '[REDACTED]';
    } else if (typeof value === 'object' && value !== null) {
      sanitized[key] = sanitizeLog(value); // Recursivo
    } else {
      sanitized[key] = value;
    }
  }
  
  return sanitized;
}

// Uso
console.log(sanitizeLog({ user: 'chris', password: 'secret123', rut: '12345678-9' }));
// Output: { user: 'chris', password: '[REDACTED]', rut: '[REDACTED]' }
```

---

## Estrategias de Cifrado

Implementamos cifrado en m√∫ltiples capas:

<Tabs>
  <TabItem label="En Tr√°nsito">
    Todo tr√°fico HTTP es **exclusivamente HTTPS (TLS 1.2+)**.

    | Control | Configuraci√≥n |
    | :--- | :--- |
    | **HSTS** | `max-age=31536000` (1 a√±o) |
    | **Certificados** | Gestionados por Cloudflare + Render |
    | **TLS Version** | M√≠nimo 1.2, preferido 1.3 |

    ```http title="Headers de Seguridad"
    Strict-Transport-Security: max-age=31536000; includeSubDomains
    X-Content-Type-Options: nosniff
    X-Frame-Options: DENY
    ```
  </TabItem>

  <TabItem label="En Reposo">
    PostgreSQL (Neon) utiliza cifrado de disco transparente. Para datos altamente sensibles, aplicamos cifrado adicional:

    ```typescript title="lib/crypto.ts"
    import { webcrypto } from 'node:crypto';

    const ALGORITHM = 'AES-GCM';
    const KEY = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex'); // 32 bytes

    export async function encrypt(text: string): Promise<string> {
      const iv = webcrypto.getRandomValues(new Uint8Array(12));
      const encoded = new TextEncoder().encode(text);
      
      const key = await webcrypto.subtle.importKey(
        'raw', KEY, ALGORITHM, false, ['encrypt']
      );
      
      const encrypted = await webcrypto.subtle.encrypt(
        { name: ALGORITHM, iv }, key, encoded
      );
      
      // Format: IV:EncryptedData
      return `${Buffer.from(iv).toString('hex')}:${Buffer.from(encrypted).toString('hex')}`;
    }

    export async function decrypt(ciphertext: string): Promise<string> {
      const [ivHex, dataHex] = ciphertext.split(':');
      const iv = Buffer.from(ivHex, 'hex');
      const data = Buffer.from(dataHex, 'hex');
      
      const key = await webcrypto.subtle.importKey(
        'raw', KEY, ALGORITHM, false, ['decrypt']
      );
      
      const decrypted = await webcrypto.subtle.decrypt(
        { name: ALGORITHM, iv }, key, data
      );
      
      return new TextDecoder().decode(decrypted);
    }
    ```

    <Aside type="danger" title="Gesti√≥n de Llaves">
      El `ENCRYPTION_KEY` es el secreto m√°s cr√≠tico. Si se pierde, los datos son **irrecuperables**. 
      Debe rotarse con extrema precauci√≥n usando scripts de re-cifrado.
    </Aside>
  </TabItem>

  <TabItem label="Hashing (Passwords)">
    Las contrase√±as **nunca** se almacenan cifradas (reversible), sino hasheadas (irreversible):

    ```typescript title="lib/hash.ts"
    import bcrypt from 'bcrypt';

    const SALT_ROUNDS = 10;

    export async function hashPassword(plain: string): Promise<string> {
      return await bcrypt.hash(plain, SALT_ROUNDS);
    }

    export async function verifyPassword(plain: string, hash: string): Promise<boolean> {
      return await bcrypt.compare(plain, hash);
    }
    ```

    | Configuraci√≥n | Valor |
    | :--- | :--- |
    | **Algoritmo** | bcrypt |
    | **Cost Factor** | 10 (m√≠nimo) |
    | **Salt** | Auto-generado por usuario |
  </TabItem>
</Tabs>

---

## Resumen de Controles por Nivel

| Nivel de Dato | Cifrado Tr√°nsito | Cifrado Reposo | Acceso | Logging |
| :--- | :---: | :---: | :--- | :--- |
| üü¢ P√∫blico | ‚úÖ HTTPS | ‚ùå | Libre | Normal |
| üü° Interno | ‚úÖ HTTPS | ‚ùå | Autenticado | Normal |
| üü† Confidencial | ‚úÖ HTTPS | ‚ùå | RBAC | Auditado |
| üî¥ Cr√≠tico | ‚úÖ HTTPS | ‚úÖ AES-256 | Restringido | Enmascarado |
